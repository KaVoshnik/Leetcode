## Алгоритм скользящего окна (Sliding Window Algorithm) на C++

Алгоритм скользящего окна - это техника, используемая для оптимизации алгоритмов, которые обрабатывают последовательность данных. Он работает путем перемещения "окна" фиксированного размера по последовательности, обрабатывая данные в окне одновременно. 

**Принцип работы:**

1. **Инициализация:** Устанавливается размер окна и устанавливается начальное положение окна в начале последовательности.
2. **Обработка данных в окне:**  Данные в текущем окне обрабатываются, выполняется требуемая операция (например, поиск максимального элемента, подсчет уникальных элементов, вычисление суммы).
3. **Перемещение окна:** Окно сдвигается на один элемент вправо.
4. **Повторение:** Шаги 2-3 повторяются до тех пор, пока окно не достигнет конца последовательности.


public:
    static inline array<int, 26> count(string& s, int l, int r){
        array<int, 26> freq={0}; // Создается массив `freq` размером 26, заполненный нулями. Этот массив будет хранить частоты встречаемости букв в строке. 26 = Кол-во букв в англ алфавите.
        for(int i=l; i<=r; i++) // Проходит по всем символам строки `s` в диапазоне от `l` до `r` (включительно).
            freq[s[i]-'a']++; // Инкрементирует значение в массиве `freq` по индексу, соответствующему букве `s[i]`. Например, для буквы 'a' индекс будет 0, для 'b' - 1 и т.д.
        return freq; // Возвращает массив `freq`, содержащий частоты встречаемости букв.
    }
    
```c++
    static bool checkInclusion(string& s1, string& s2) {
        const int n1=s1.size(), n2=s2.size(); // Сохраняет длины строк `s1` и `s2` в переменные `n1` и `n2` соответственно.
        if (n2<n1) return 0; // Если строка `s2` короче строки `s1`, то `s1` не может быть подстрокой `s2`, возвращает `false`.
        auto freq1=count(s1, 0, n1-1); // Вычисляет частоты встречаемости букв в строке `s1` с помощью функции `count` и сохраняет результат в `freq1`.
        auto freq2=count(s2, 0, n1-1); // Вычисляет частоты встречаемости букв в строке `s2` с помощью функции `count` и сохраняет результат в `freq2`.
        if (freq1==freq2) return 1; // Если частоты встречаемости букв в `s1` и `s2` совпадают, то `s1` является подстрокой `s2`, возвращает `true`.
        for(int l=1, r=n1; r<n2; r++, l++){ // Проходит по всем возможным подстрокам в `s2`, длина которых равна длине `s1`.
            freq2[s2[l-1]-'a']--; // Уменьшает частоту встречаемости буквы `s2[l-1]` в `freq2`. 
            freq2[s2[r]-'a']++; // Увеличивает частоту встречаемости буквы `s2[r]` в `freq2`. 
            if (freq2== freq1) return 1; // Если частоты встречаемости букв в `freq1` и `freq2` совпадают, то `s1` является подстрокой `s2`, возвращает `true`.
        }
        return 0; // Если цикл завершен и ни одно из условий не выполнилось, то `s1` не является подстрокой `s2`, возвращает `false`.
    }
};
```
